/**
 * Copyright (c) 2013 European Organisation for Nuclear Research (CERN), All Rights Reserved.
 */

package org.tensorics.core.testing;

import static java.util.stream.Collectors.toList;
import static org.tensorics.core.testing.PojoClassFilters.excludeTestClasses;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.openpojo.reflection.PojoClass;
import com.openpojo.reflection.PojoClassFilter;
import com.openpojo.reflection.filters.FilterChain;
import com.openpojo.reflection.filters.FilterCloverClasses;
import com.openpojo.reflection.filters.FilterNestedClasses;
import com.openpojo.reflection.filters.FilterPackageInfo;
import com.openpojo.reflection.impl.PojoClassFactory;

/**
 * Provides utility methods for tests used in combination with openpojo
 *
 * @author kfuchsbe
 */
public final class PojoTests {

    /**
     * private constructor to avoid instantiation
     */
    private PojoTests() {
        /* only static methods */
    }

    /**
     * creates parameters which are conform with a {@link AbstractPojoTest}, taking classes from below the given package
     * name and taking into account the given filters. The following filters are applied by default:
     * <ul>
     * <li>{@link FilterPackageInfo}: Ignores the package-info.java
     * <li>{@link ExcludeTestClassesFilter}: Ignores test classes
     * <li>{@link FilterCloverClasses}: Ignores all classes generated by clover instrumentation
     * <li>{@link FilterNestedClasses}: Ignores all nested classes
     * </ul>
     *
     * @param packageName the package name, from which to start searching for classes
     * @param classFilters the filters for the classes which will be used
     * @return a list of objects, which will represent a parameter array of className - class pairs. These can be
     *         directly used in a test which extends {@link AbstractPojoTest}.
     */
    public static List<Class<?>> pojocClassesForPackageName(String packageName, PojoClassFilter... classFilters) {

        List<PojoClassFilter> filters = new ArrayList<>();
        filters.addAll(Arrays.asList(
                new PojoClassFilter[] { new FilterPackageInfo(), excludeTestClasses(), new FilterCloverClasses() }));
        filters.addAll(Arrays.asList(classFilters));

        List<PojoClass> pojoClasses = PojoClassFactory.getPojoClassesRecursively(packageName,
                new FilterChain(filters.toArray(new PojoClassFilter[] {})));

        return pojoClasses.stream().map(pc -> pc.getClazz()).collect(toList());
    }

    /**
     * creates parameters which are conform with a {@link AbstractPojoTest}, taking classes from below all given package
     * names and taking into account the given filters. This is a convenience method for calling
     * {@link #pojocClassesForPackageName(String, PojoClassFilter...)} with many package names.
     *
     * @param packageNames the package names which shall be searched recursively for classes
     * @param classFilters the filters which shall be applied to the found classes
     * @return a list of objects, which will represent an array of parameters for the {@link AbstractPojoTest}. (Pairs
     *         of className + class)
     * @see #pojocClassesForPackageName(String, PojoClassFilter...)
     */
    public static List<Class<?>> pojoClassesForPackageNames(String[] packageNames, PojoClassFilter... classFilters) {
        List<Class<?>> parameters = new ArrayList<>();
        for (String packageName : packageNames) {
            parameters.addAll(pojocClassesForPackageName(packageName, classFilters));
        }
        System.out.println("Found " + parameters.size() + " matching classes.");
        return parameters;
    }

}
